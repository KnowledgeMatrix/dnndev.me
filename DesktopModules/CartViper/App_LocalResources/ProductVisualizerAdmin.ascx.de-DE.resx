<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="btnDelete.Text" xml:space="preserve">
    <value>Löschen</value>
  </data>
  <data name="btnUpload.Text" xml:space="preserve">
    <value>Laden</value>
  </data>
  <data name="dshUploadNewBaseImage.Text" xml:space="preserve">
    <value>Upload New Base Image</value>
  </data>
  <data name="hypAddNew.Text" xml:space="preserve">
    <value>Add New Marker</value>
  </data>
  <data name="hypCancel.Text" xml:space="preserve">
    <value>Stornieren</value>
  </data>
  <data name="hypEditproduct.Text" xml:space="preserve">
    <value>Produkt bearbeiten</value>
  </data>
  <data name="hypSave.Text" xml:space="preserve">
    <value>Sparen</value>
  </data>
  <data name="lblBaseImage.Help" xml:space="preserve">
    <value>Die aktuelle Basis-Image, dass in dem Produkt-Visualisierung verwendet werden.</value>
  </data>
  <data name="lblBaseImage.Text" xml:space="preserve">
    <value>Aktuelle Base Image</value>
  </data>
  <data name="lblDeleteExistingBaseImage.Help" xml:space="preserve">
    <value>Diese Taste löscht die bestehende Basis Image und alle damit verbundenen Marken.</value>
  </data>
  <data name="lblDeleteExistingBaseImage.Text" xml:space="preserve">
    <value>Löschen Sie vorhandene Base Image</value>
  </data>
  <data name="lblFont.Help" xml:space="preserve">
    <value>Ist dies eine Markierung, wo der Text eingefügt werden soll, wählen Sie den Stil des Textes wird. Wenn dies nicht anwendbar ist leer.</value>
  </data>
  <data name="lblFont.Text" xml:space="preserve">
    <value>Schriftschnitt</value>
  </data>
  <data name="lblFontColour.Help" xml:space="preserve">
    <value>Ist dies eine Markierung, wo der Text eingefügt werden soll, wählen Sie die Farbe des Textes wird. Ist dies nicht zutreffend bitte leer lassen.</value>
  </data>
  <data name="lblFontColour.Text" xml:space="preserve">
    <value>Farbe, Schrift</value>
  </data>
  <data name="lblHeaderText.Text" xml:space="preserve">
    <value>Produkt Visualizer</value>
  </data>
  <data name="lblMaxNumberOfCharactersAllowed.Help" xml:space="preserve">
    <value>Gegebenenfalls die maximium Anzahl der Zeichen, dass der Benutzer in der Markierung zu setzen.</value>
  </data>
  <data name="lblMaxNumberOfCharactersAllowed.Text" xml:space="preserve">
    <value>Maximium No: Characters</value>
  </data>
  <data name="lblNoImageUploaded.Text" xml:space="preserve">
    <value>Kein Bild hochgeladen.</value>
  </data>
  <data name="lblTextAlignment.Help" xml:space="preserve">
    <value>Ist dies eine Markierung, wo der Text eingefügt werden soll, sollte, wie der Text innerhalb der Markierung ausgerichtet werden.</value>
  </data>
  <data name="lblTextAlignment.Text" xml:space="preserve">
    <value>Textausrichtung</value>
  </data>
  <data name="lblUploadBaseImage.Help" xml:space="preserve">
    <value>Von hier aus können Sie ein Basis-Image, dass in dem Produkt-Visualisierung verwendet werden hochladen, beachten Sie nur 1 Bild pro Produkt hochgeladen werden können.</value>
  </data>
  <data name="lblUploadBaseImage.Text" xml:space="preserve">
    <value>Upload Base Image</value>
  </data>
  <data name="lblVariantOption.Help" xml:space="preserve">
    <value>Die Variante Option, die in die Markierung, wenn die Mockup Bild erstellt wird und dem Benutzer angezeigt gestellt werden.</value>
  </data>
  <data name="lblVariantOption.Text" xml:space="preserve">
    <value>Variant Option</value>
  </data>
  <data name="lblVisualizerInfo.Text" xml:space="preserve">
    <value>Wenn ein Produkt-Varianten hat es möglich ist, den Benutzer, was das Produkt wie bei den Anpassungen die sie gemacht haben Blick zeigen. Zunächst laden Sie ein Basis-Image, dann fügen Sie Marker, um das Basis-Image für jede Anpassung eines Benutzers können, wobei darauf geachtet, um die Markierung in die Position auf dem Basis-Image, wo die Nutzer Anpassung erscheint Position. &lt;br /&gt; Wenn die Anpassung fügt Text in der Markierung, wählen Sie bitte eine Schriftart Farbe, Stil und Charakter zu begrenzen, ansonsten lassen Sie dieses Feld leer. &lt;br /&gt; Wenn ein Bild in den Marker eingesetzt werden die Benutzer Bild wird automatisch so skaliert, dass die Markierung von Ihnen festgelegten Größe zu passen.</value>
  </data>
</root>